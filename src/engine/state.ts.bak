import { computed, ref, toRaw } from "vue";
import { z } from "zod";
import { UserIntentSchema, type UserIntent, type Question, type QuestionOption } from "~/data/types";
import { ALL_QUESTIONS, QUESTION_PHASES } from "~/data/questions";
import { CompatibilityResultListSchema, type CompatibilityResult } from "~/data/compatibility-types";
import type { Distro } from "~/data/distro-types";
import {
    ConstraintTemplates,
    ExclusionReasonTemplates,
    InclusionReasonTemplates,
    type ConstraintKey,
    type ExclusionReasonKey,
    type InclusionReasonKey,
} from "~/data/reason-templates";
import { applyPatch, evaluateCondition } from "~/engine/logic";
import { getDistros } from "~/engine/eliminate";
import { buildCompatibility } from "~/engine/compatibility";

export type EngineStatus = "IN_PROGRESS" | "COMPLETED" | "DISQUALIFIED";

export interface SessionState {
    intent: UserIntent;
    answeredIds: string[]; // order matters
    status: EngineStatus;
    disqualifyReason?: string;
}

interface Snapshot {
    intent: UserIntent;
    answeredIds: string[];
    status: EngineStatus;
    disqualifyReason?: string;
    appliedPatches: string[];
    lastAppliedPatches: string[];
    answerHistory: AnswerRecord[];
}

const SessionStateSchema = z.object({
    intent: UserIntentSchema,
    answeredIds: z.array(z.string()),
    status: z.enum(["IN_PROGRESS", "COMPLETED", "DISQUALIFIED"]),
    disqualifyReason: z.string().optional(),
});

const SharePayloadSchema = z.object({
    intent: UserIntentSchema,
    answeredIds: z.array(z.string()),
});

export type SharePayload = z.infer<typeof SharePayloadSchema>;

const defaultIntent: UserIntent = UserIntentSchema.parse({
    installation: "GUI",
    maintenance: "NO_TERMINAL",
    proprietary: "OPTIONAL",
    architecture: "x86_64",
    minRam: 4,
    tags: [],
    experience: "BEGINNER",
    desktopPreference: "NO_PREFERENCE",
    releaseModel: "NO_PREFERENCE",
    initSystem: "NO_PREFERENCE",
    packageManager: "NO_PREFERENCE",
    secureBootNeeded: null,
    gpu: "UNKNOWN",
    nvidiaTolerance: "NO_PREFERENCE",
});

export type AnswerRecord = {
    questionId: string;
    questionText: string;
    optionId: string;
    optionLabel: string;
};

export type AnswerGroup = {
    phaseKey: (typeof QUESTION_PHASES)[number]["key"];
    phaseLabel: string;
    answers: AnswerRecord[];
};

export type ProgressVM = {
    current: number;
    total: number;
    percent: number;
    phaseLabel: string;
};

export type QuestionOptionVM = {
    id: string;
    label: string;
    description?: string;
};

export type QuestionVM = {
    id: string;
    text: string;
    options: QuestionOptionVM[];
};

export type PhaseGateVM = QuestionVM;

export type AnswerVM = {
    questionId: string;
    questionText: string;
    optionLabel: string;
    phaseLabel: string;
};

export type WizardMode = "QUESTION" | "PHASE_GATE" | "COMPLETE" | "DISQUALIFIED";

export type DistroCardVM = {
    id: string;
    name: string;
    description?: string;
    reasonsIncluded: string[];
    reasonsFriction: string[];
};

export type ResultsVM = {
    shortlist: DistroCardVM[];
    allCompatible: DistroCardVM[];
    excluded: { name: string; reason: string }[];
    activeConstraints: string[];
};

export type DebugVM = {
    intent: UserIntent;
    status: EngineStatus;
    answeredIds: string[];
    currentQuestionId?: string;
};

type PhaseKey = AnswerGroup["phaseKey"];

const experiencePhaseLabel: Record<UserIntent["experience"], string> = {
    BEGINNER: "Beginner",
    INTERMEDIATE: "Refine",
    ADVANCED: "Expert",
};

const RESULTS_SHORTLIST_LIMIT = 3;

const questionPhaseLookup = new Map<string, { key: PhaseKey; label: string }>();
QUESTION_PHASES.forEach((phase) => {
    phase.questionIds.forEach((questionId) => {
        questionPhaseLookup.set(questionId, { key: phase.key, label: phase.label });
    });
});

const distrosForVM = getDistros();

export function useDecisionEngine() {
    const debugEnabled = import.meta.dev;

    // Single source of truth (reactive)
    const intent = ref<UserIntent>(structuredClone(defaultIntent));
    const answeredIds = ref<string[]>([]);
    const status = ref<EngineStatus>("IN_PROGRESS");
    const disqualifyReason = ref<string | undefined>(undefined);

    // History for undo
    const history = ref<Snapshot[]>([]);
    const appliedPatches = ref<string[]>([]);
    const lastAppliedPatches = ref<string[]>([]);
    const answerHistory = ref<AnswerRecord[]>([]);

    // Derived: visible questions given current intent
    const visibleQuestions = computed<Question[]>(() => {
        return ALL_QUESTIONS.filter((q) => {
            if (!q.showIf) return true;
            return evaluateCondition(intent.value, q.showIf);
        });
    });

    // Derived: first visible unanswered question
    const currentQuestion = computed<Question | undefined>(() => {
        if (status.value !== "IN_PROGRESS") return undefined;

        const next = visibleQuestions.value.find((q) => !answeredIds.value.includes(q.id));
        if (!next) {
            // No remaining visible questions: complete deterministically
            status.value = "COMPLETED";
            return undefined;
        }
        return next;
    });

    const isComplete = computed(() => status.value === "COMPLETED");
    const isDisqualified = computed(() => status.value === "DISQUALIFIED");
    const progress = computed(() => {
        const total = visibleQuestions.value.length;
        const visibleIds = new Set(visibleQuestions.value.map((question) => question.id));
        const answered = answeredIds.value.filter((id) => visibleIds.has(id)).length;
        const percent = total === 0 ? 100 : Math.min(100, Math.round((answered / total) * 100));
        const current = total === 0 ? 0 : Math.min(total, answered + 1);
        return { total, answered, percent, current };
    });

    const phaseLabel = computed(() => experiencePhaseLabel[intent.value.experience]);

    const progressVM = computed<ProgressVM>(() => ({
        current: progress.value.current,
        total: progress.value.total,
        percent: progress.value.percent,
        phaseLabel: phaseLabel.value,
    }));

    const currentQuestionVM = computed<QuestionVM | null>(() => {
        if (!currentQuestion.value) return null;
        return {
            id: currentQuestion.value.id,
            text: currentQuestion.value.text,
            options: currentQuestion.value.options.map((option) => ({
                id: option.id,
                label: option.label,
                description: option.description,
            })),
        };
    });

    const answeredGroups = computed<AnswerGroup[]>(() => {
        const groups = QUESTION_PHASES.map((phase) => ({
            phaseKey: phase.key,
            phaseLabel: phase.label,
            answers: [] as AnswerRecord[],
        }));

        const groupMap = new Map<PhaseKey, (typeof groups)[number]>();
        groups.forEach((group) => groupMap.set(group.phaseKey, group));

        answerHistory.value.forEach((answer) => {
            const phase = questionPhaseLookup.get(answer.questionId) ?? {
                key: QUESTION_PHASES[0].key,
                label: QUESTION_PHASES[0].label,
            };
            const group = groupMap.get(phase.key);
            if (group) {
                group.answers.push(answer);
            }
        });

        return groups.filter((group) => group.answers.length > 0);
    });

    const answersVM = computed<AnswerVM[]>(() => {
        return answerHistory.value.map((answer) => {
            const phase = questionPhaseLookup.get(answer.questionId) ?? {
                key: QUESTION_PHASES[0].key,
                label: QUESTION_PHASES[0].label,
            };

            return {
                questionId: answer.questionId,
                questionText: answer.questionText,
                optionLabel: answer.optionLabel,
                phaseLabel: phase.label,
            };
        });
    });

    const wizardMode = computed<WizardMode>(() => {
        if (status.value === "DISQUALIFIED") return "DISQUALIFIED";
        if (status.value === "COMPLETED") return "COMPLETE";
        if (currentQuestion.value?.id === "q_phase_exit") return "PHASE_GATE";
        return "QUESTION";
    });

    const phaseGateVM = computed<PhaseGateVM | null>(() => {
        if (wizardMode.value !== "PHASE_GATE") return null;
        return currentQuestionVM.value;
    });

    const resultsVM = computed<ResultsVM>(() => {
        if (status.value !== "COMPLETED") {
            return {
                shortlist: [],
                allCompatible: [],
                excluded: [],
                activeConstraints: [],
            };
        }

        const presentation = buildResultsPresentation(intent.value, distrosForVM, {
            limit: RESULTS_SHORTLIST_LIMIT,
            showAll: true,
        });

        const toCardVM = (item: PresentedDistro): DistroCardVM => ({
            id: item.distroId,
            name: item.name,
            description: item.description,
            reasonsIncluded: item.includedBecause,
            reasonsFriction: item.excludedBecause,
        });

        const allCompatible = presentation.compatible.map(toCardVM);
        const shortlist = allCompatible.slice(0, RESULTS_SHORTLIST_LIMIT);
        const excluded = presentation.excluded.flatMap((item) => {
            if (item.excludedBecause.length === 0) {
                return [{ name: item.name, reason: "Excluded by your constraints." }];
            }

            return item.excludedBecause.map((reason) => ({
                name: item.name,
                reason,
            }));
        });

        return {
            shortlist,
            allCompatible,
            excluded,
            activeConstraints: presentation.activeConstraints,
        };
    });

    const debugVM = computed<DebugVM>(() => ({
        intent: intent.value,
        status: status.value,
        answeredIds: answeredIds.value,
        currentQuestionId: currentQuestion.value?.id,
    }));

    const canUndo = computed(() => answeredIds.value.length > 0);

    const skippedQuestions = computed(() => {
        if (!debugEnabled) return [];
        return ALL_QUESTIONS.filter((q) => q.showIf && !evaluateCondition(intent.value, q.showIf)).map((q) => ({
            questionId: q.id,
            showIf: q.showIf,
            showIfJson: JSON.stringify(q.showIf),
        }));
    });

    function selectOption(questionId: string, option: QuestionOption) {
        if (status.value !== "IN_PROGRESS") return;

        // Snapshot for undo
        history.value.push({
            intent: structuredClone(toRaw(intent.value)),
            answeredIds: [...answeredIds.value],
            status: status.value,
            disqualifyReason: disqualifyReason.value,
            appliedPatches: [...appliedPatches.value],
            lastAppliedPatches: [...lastAppliedPatches.value],
            answerHistory: [...answerHistory.value],
        });

        const question = ALL_QUESTIONS.find((item) => item.id === questionId);
        const record: AnswerRecord = {
            questionId,
            questionText: question?.text ?? questionId,
            optionId: option.id,
            optionLabel: option.label,
        };

        // Disqualifier: stop immediately (do NOT apply patches unless you explicitly want to)
        if (option.isDisqualifier) {
            status.value = "DISQUALIFIED";
            disqualifyReason.value = option.label;
            if (!answeredIds.value.includes(questionId)) answeredIds.value.push(questionId);
            if (!answerHistory.value.some((item) => item.questionId === questionId)) {
                answerHistory.value.push(record);
            }
            lastAppliedPatches.value = [];
            return;
        }

        lastAppliedPatches.value = option.patches.map((patch) => JSON.stringify(patch));

        if (debugEnabled) {
            const label = `q:${questionId} -> ${option.id}`;
            const serialized = option.patches.map((patch) => JSON.stringify(patch)).join(", ");
            appliedPatches.value.push(serialized ? `${label} [${serialized}]` : `${label} []`);
        }

        // Apply patches (validated)
        intent.value = applyPatch(toRaw(intent.value), option.patches);

        // Mark answered (by ID, not index)
        if (!answeredIds.value.includes(questionId)) answeredIds.value.push(questionId);
        if (!answerHistory.value.some((item) => item.questionId === questionId)) {
            answerHistory.value.push(record);
        }
    }

    function undo() {
        const prev = history.value.pop();
        if (!prev) return;

        intent.value = prev.intent;
        answeredIds.value = prev.answeredIds;
        status.value = prev.status;
        disqualifyReason.value = prev.disqualifyReason;
        appliedPatches.value = prev.appliedPatches;
        lastAppliedPatches.value = prev.lastAppliedPatches;
        answerHistory.value = prev.answerHistory;
    }

    function selectOptionById(optionId: string) {
        const question = currentQuestion.value;
        if (!question) return;
        const option = question.options.find((item) => item.id === optionId);
        if (!option) return;
        selectOption(question.id, option);
    }

    function reset() {
        intent.value = structuredClone(defaultIntent);
        answeredIds.value = [];
        status.value = "IN_PROGRESS";
        disqualifyReason.value = undefined;
        history.value = [];
        appliedPatches.value = [];
        lastAppliedPatches.value = [];
        answerHistory.value = [];
    }

    function editAnswer(questionId: string) {
        const index = answeredIds.value.indexOf(questionId);
        if (index === -1) return;
        const snapshot = history.value[index];
        if (!snapshot) return;

        intent.value = snapshot.intent;
        answeredIds.value = snapshot.answeredIds;
        status.value = "IN_PROGRESS";
        disqualifyReason.value = undefined;
        appliedPatches.value = snapshot.appliedPatches;
        lastAppliedPatches.value = snapshot.lastAppliedPatches;
        answerHistory.value = snapshot.answerHistory;
        history.value = history.value.slice(0, index);
    }

    function serializeSession(): string {
        const snapshot: SessionState = {
            intent: intent.value,
            answeredIds: answeredIds.value,
            status: status.value,
            disqualifyReason: disqualifyReason.value,
        };
        return JSON.stringify(snapshot);
    }

    const validateAnsweredIds = (ids: string[]) => {
        const validIds = new Set(ALL_QUESTIONS.map((q) => q.id));
        const seen = new Set<string>();
        for (const id of ids) {
            if (!validIds.has(id)) throw new Error(`Unknown question id: ${id}`);
            if (seen.has(id)) throw new Error(`Duplicate answered id: ${id}`);
            seen.add(id);
        }
    };

    function restoreSession(serialized: string): boolean {
        try {
            const parsed = JSON.parse(serialized);
            const restored = SessionStateSchema.parse(parsed);

            validateAnsweredIds(restored.answeredIds);

            intent.value = restored.intent;
            answeredIds.value = [...restored.answeredIds];
            status.value = restored.status;
            disqualifyReason.value = restored.disqualifyReason;
            history.value = [];
            appliedPatches.value = [];
            lastAppliedPatches.value = [];
            answerHistory.value = [];
            return true;
        } catch {
            return false;
        }
    }

    function getSharePayload(): SharePayload {
        return {
            intent: structuredClone(toRaw(intent.value)),
            answeredIds: [...answeredIds.value],
        };
    }

    function restoreSharePayload(payload: SharePayload): boolean {
        try {
            const restored = SharePayloadSchema.parse(payload);
            validateAnsweredIds(restored.answeredIds);

            intent.value = restored.intent;
            answeredIds.value = [...restored.answeredIds];
            status.value = "IN_PROGRESS";
            disqualifyReason.value = undefined;
            history.value = [];
            appliedPatches.value = [];
            lastAppliedPatches.value = [];
            answerHistory.value = [];
            return true;
        } catch {
            return false;
        }
    }

    return {
        // state
        intent,
        answeredIds,
        status,
        disqualifyReason,
        debugEnabled,
        appliedPatches,
        lastAppliedPatches,
        answeredQuestions: answerHistory,
        answeredGroups,
        phaseLabel,
        progressVM,
        currentQuestionVM,
        phaseGateVM,
        answersVM,
        wizardMode,
        resultsVM,
        debugVM,
        canUndo,

        // derived
        visibleQuestions,
        currentQuestion,
        isComplete,
        isDisqualified,
        progress,
        skippedQuestions,

        // actions
        selectOption,
        selectOptionById,
        undo,
        editAnswer,
        reset,
        serializeSession,
        restoreSession,
        getSharePayload,
        restoreSharePayload,
    };
}

export type DecisionEngine = ReturnType<typeof useDecisionEngine>;

export function buildCompatibilityResults(intent: UserIntent): CompatibilityResult[] {
    return buildCompatibility(intent);
}

export type PresentedDistro = {
    distroId: string;
    name: string;
    description?: string;
    includedBecause: string[];
    excludedBecause: string[];
    matchedConstraints: string[];
};

export type ResultsPresentation = {
    compatible: PresentedDistro[];
    excluded: PresentedDistro[];
    compatibleTotal: number;
    compatibleShown: number;
    activeConstraints: string[];
};

type PresentationOptions = {
    limit: number;
    showAll: boolean;
};

const sortByDistroId = (a: CompatibilityResult, b: CompatibilityResult) => {
    return a.distroId.localeCompare(b.distroId);
};

const getActiveConstraintKeys = (intent: UserIntent): ConstraintKey[] => {
    const constraints: ConstraintKey[] = [];

    if (intent.installation === "GUI") {
        constraints.push("constraint_installer_gui");
    }

    if (intent.maintenance === "NO_TERMINAL") {
        constraints.push("constraint_maintenance_low_friction");
    }

    if (intent.proprietary === "AVOID") {
        constraints.push("constraint_proprietary_none");
    }

    if (intent.proprietary === "REQUIRED") {
        constraints.push("constraint_proprietary_allowed");
    }

    if (intent.tags.includes("OldHardware")) {
        constraints.push("constraint_old_hardware");
    }

    if (intent.tags.includes("Gaming")) {
        constraints.push("constraint_gaming_support");
    }

    if (intent.tags.includes("Privacy")) {
        constraints.push("constraint_privacy_strong");
    }

    if (intent.secureBootNeeded === true) {
        constraints.push("constraint_secure_boot_required");
    }

    if (intent.gpu === "NVIDIA" && intent.nvidiaTolerance === "WANT_EASY") {
        constraints.push("constraint_nvidia_easy");
    }

    if (intent.gpu === "NVIDIA" && intent.proprietary === "AVOID") {
        constraints.push("constraint_nvidia_avoid_proprietary");
    }

    if (intent.desktopPreference === "GNOME") {
        constraints.push("constraint_desktop_gnome");
    } else if (intent.desktopPreference === "KDE") {
        constraints.push("constraint_desktop_kde");
    } else if (intent.desktopPreference === "XFCE") {
        constraints.push("constraint_desktop_xfce");
    } else if (intent.desktopPreference === "CINNAMON") {
        constraints.push("constraint_desktop_cinnamon");
    } else if (intent.desktopPreference === "MATE") {
        constraints.push("constraint_desktop_mate");
    } else if (intent.desktopPreference === "LXQT") {
        constraints.push("constraint_desktop_lxqt");
    }

    if (intent.releaseModel === "FIXED") {
        constraints.push("constraint_release_fixed");
    } else if (intent.releaseModel === "ROLLING") {
        constraints.push("constraint_release_rolling");
    }

    if (intent.initSystem === "SYSTEMD") {
        constraints.push("constraint_init_systemd");
    } else if (intent.initSystem === "OPENRC") {
        constraints.push("constraint_init_openrc");
    } else if (intent.initSystem === "RUNIT") {
        constraints.push("constraint_init_runit");
    }

    if (intent.packageManager === "APT") {
        constraints.push("constraint_pkg_apt");
    } else if (intent.packageManager === "DNF") {
        constraints.push("constraint_pkg_dnf");
    } else if (intent.packageManager === "PACMAN") {
        constraints.push("constraint_pkg_pacman");
    } else if (intent.packageManager === "ZYPPER") {
        constraints.push("constraint_pkg_zypper");
    } else if (intent.packageManager === "APK") {
        constraints.push("constraint_pkg_apk");
    } else if (intent.packageManager === "NIX") {
        constraints.push("constraint_pkg_nix");
    }

    return constraints;
};

const matchesConstraint = (constraint: ConstraintKey, distro: Distro): boolean => {
    switch (constraint) {
        case "constraint_installer_gui":
            return distro.installerExperience === "GUI";
        case "constraint_maintenance_low_friction":
            return distro.maintenanceStyle === "LOW_FRICTION";
        case "constraint_proprietary_none":
            return distro.proprietarySupport === "NONE";
        case "constraint_proprietary_allowed":
            return distro.proprietarySupport !== "NONE";
        case "constraint_old_hardware":
            return distro.suitableForOldHardware;
        case "constraint_gaming_support":
            return distro.gamingSupport !== "NONE";
        case "constraint_privacy_strong":
            return distro.privacyPosture === "STRONG";
        case "constraint_secure_boot_required":
            return distro.secureBootOutOfBox;
        case "constraint_nvidia_easy":
            return distro.nvidiaExperience === "GOOD" || distro.nvidiaExperience === "OK";
        case "constraint_nvidia_avoid_proprietary":
            return distro.nvidiaExperience === "HARD" || distro.nvidiaExperience === "UNKNOWN";
        case "constraint_desktop_gnome":
            return distro.supportedDesktops.includes("GNOME");
        case "constraint_desktop_kde":
            return distro.supportedDesktops.includes("KDE");
        case "constraint_desktop_xfce":
            return distro.supportedDesktops.includes("XFCE");
        case "constraint_desktop_cinnamon":
            return distro.supportedDesktops.includes("CINNAMON");
        case "constraint_desktop_mate":
            return distro.supportedDesktops.includes("MATE");
        case "constraint_desktop_lxqt":
            return distro.supportedDesktops.includes("LXQT");
        case "constraint_release_fixed":
            return distro.releaseModel === "FIXED";
        case "constraint_release_rolling":
            return distro.releaseModel === "ROLLING";
        case "constraint_init_systemd":
            return distro.initSystem === "SYSTEMD";
        case "constraint_init_openrc":
            return distro.initSystem === "OPENRC";
        case "constraint_init_runit":
            return distro.initSystem === "RUNIT";
        case "constraint_pkg_apt":
            return distro.packageManager === "APT";
        case "constraint_pkg_dnf":
            return distro.packageManager === "DNF";
        case "constraint_pkg_pacman":
            return distro.packageManager === "PACMAN";
        case "constraint_pkg_zypper":
            return distro.packageManager === "ZYPPER";
        case "constraint_pkg_apk":
            return distro.packageManager === "APK";
        case "constraint_pkg_nix":
            return distro.packageManager === "NIX";
        default:
            return false;
    }
};

const renderInclusionReasons = (reasons: InclusionReasonKey[]): string[] => {
    return reasons.map((reason) => InclusionReasonTemplates[reason]);
};

const renderExclusionReasons = (reasons: ExclusionReasonKey[]): string[] => {
    return reasons.map((reason) => ExclusionReasonTemplates[reason]);
};

export function buildResultsPresentation(
    intent: UserIntent,
    distros: Distro[],
    options: PresentationOptions
): ResultsPresentation {
    const results = CompatibilityResultListSchema.parse(buildCompatibility(intent));
    const distrosById = new Map(distros.map((distro) => [distro.id, distro] as const));

    const compatibleAll = results.filter((item) => item.compatible).sort(sortByDistroId);
    const excludedAll = results.filter((item) => !item.compatible).sort(sortByDistroId);

    const compatibleShown = options.showAll ? compatibleAll : compatibleAll.slice(0, options.limit);
    const activeConstraintKeys = getActiveConstraintKeys(intent);
    const activeConstraints = activeConstraintKeys.map((key) => ConstraintTemplates[key]);

    const presentCompatible = (result: CompatibilityResult): PresentedDistro => {
        const distro = distrosById.get(result.distroId);
        const matchedConstraints = distro
            ? activeConstraintKeys
                  .filter((constraint) => matchesConstraint(constraint, distro))
                  .map((constraint) => ConstraintTemplates[constraint])
            : [];

        return {
            distroId: result.distroId,
            name: distro?.name ?? result.distroId,
            description: distro?.description,
            includedBecause: renderInclusionReasons(result.includedBecause),
            excludedBecause: [],
            matchedConstraints,
        };
    };

    const presentExcluded = (result: CompatibilityResult): PresentedDistro => {
        const distro = distrosById.get(result.distroId);
        return {
            distroId: result.distroId,
            name: distro?.name ?? result.distroId,
            description: distro?.description,
            includedBecause: [],
            excludedBecause: renderExclusionReasons(result.excludedBecause),
            matchedConstraints: [],
        };
    };

    return {
        compatible: compatibleShown.map(presentCompatible),
        excluded: excludedAll.map(presentExcluded),
        compatibleTotal: compatibleAll.length,
        compatibleShown: compatibleShown.length,
        activeConstraints,
    };
}
